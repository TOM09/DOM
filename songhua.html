<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>

	<body>
		<script type="text/javascript">
			var str = "ads asd asd x!!x";
			console.log(str);
			console.log(str.replace(/\b/g,""));
			
			
			var str = "asd li asd"
			var sClass = "li"
			var re = new RegExp('\\b'+sClass+'\\b')
			console.log(re.test(str))
			
			var str123 = "a11ca222ca333ca44444412ca123ca123ca23c"
			console.log(str123.match(/a(\d)\1+c/g))
			
			var str1234 = "a3433ca545ca646c"
			str1234.replace(/a(\d)4\1\1+c/g,function($0,$1,$2){
				console.log($1);
			})
			
			
			var stra = "asdfkjas1dfasdfaaaadshj12fshjxbxgtw34ysa5n";
			var min = -Infinity;
			var num = "";
			// 用空字符切割 放到数组里  对其进行排序    再用空字符拼接成一个字符串
			stra = stra.split('').sort().join('');
			console.log(stra)
			
			stra.replace(/(\w)\1+/g,function($0,$1){
				if(min < $0.length){
					min = $0.length;
					num = $1;
				}
			console.log(num)
//			console.log(s)
			})
				console.log("最长的是"+num+"次数是"+min)
			
//			console.log(str123.match(/a(\d)\1+c/g))

			/*正则复习:
			匹配或者检索(擅长模糊范围的)字符串的规则.
			方法:
			正则.test(),    返回布尔值
			str.search(正则),    返回的是索引值或者是-1
			str.match(正则),      返回数组或者是空
			
			str.replace(被替换的字符||正则,替换字符||function);
			
			function($0,$1,$2){			}
			$0 当前匹配的字符.
			$1没有子项:index   有子项就是子项
			$2 没有子项:整个字符串     有第二个子项就第二个子项

			()
			子项  \1  重复第一个子项
			提权
			
			[] A-Za-z 0-9 \u4e00--\u9fa5
			[^排除]
			
			{n,m}n到m
			{n,}最小N个  最大无限
			
			+ 匹配多个
			?可以没有 最多1个
			* 最小0个  最多无限
			
			修饰符:
			i	忽略大小写
			g	全局*/
			.    任意符
			
			var strz = 'ascagsclkfdglskdcjfgb'
			 console.log(strz.match(/a.+c/g));
			 
			 \s
			 \S
			 \w
			 \W
			 \d
			 \D
			 \b
			 \B
			 
			 ^ 开头
			 $ 结尾
		</script>
	</body>

</html>