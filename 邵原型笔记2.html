<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<div></div>
		<div></div>
		<div></div>
		<script type="text/javascript">
/*	一,原型链深入
	
	EX6里  可以用Object.create(obj)  使对象指向新对象的原型.
	var obj1 = {"a":1,"b":2}
	var obj2 = Object.create(obj2)
	obj2._proto_ ===obj1;
	所以:obj2.a = 1
		obj2.b = 2
	
	兼容写法
	function create(obj){
		function f(){};
		f.prototype = obj;
		return new f();
	}
		
二.对象的种类归属辨别
	任何一个构造函数的prototype身上都有一个constructor属性,指向构造函数
	constructor:构造器
	
	function B(){
		return new A();
	}
	此时我们 new B() 实际上实例是A的实例,此时实例的constructor指向A.
	constructor属性确实在构造函数的prototype身上,但是这个属性是不可枚举的.
	也就是说,如果我们遇见
	obj.constructor === 构造函数   //true
	此时我们稍稍可以认为obj是这个构造函数的实例.
	
三.  instanceof 运算符
	这个运算符用来检测某一个对象是不是某一个构造函数的实例.
	语法:obj.instanceof 函数
	如果函数的prototype在对象的原型链上,返回true.反之返回false.
	换句话说:
	如果对象的原型链上,恰好有某一个元素是函数的prototype,此时返回true.反之返回false.
	所以:
	obj.prototype是所有人的原型链的终点,所以,
	obj.prototype是所有人的原型链的终点,所以,
	
	鸭式辩型  :如果一个动物能够嘎嘎叫 走路摇摆  黄色    那它就是鸭子
	任何对象.instanceof object   //true
	总结:在js中,我们没有一种可靠的办法去探寻一个元素是不是一个构造函数的实例
	*/
	/*
四.原型的继承 extend.
	人类和狗类有相交的属性,但是没有继承,他们没有关系.
	大圈包小圈,大圈继承自小圈.
	在计算机中,继承者要比被继承者大.比如 小学生和人类.人拥有的属性,小学生都有.
	但是小学生拥有的,人不一定有.所以小学生继承(extend)了人类.
	A继承了B,此时要意识到:
	1.A拥有B的所有属性和方法
	2.A拥有的属性群比B更大
	3.A丰富了B,A把B变得更具体,范围更小.
	
	js来实现两个类,People类,student类,要求是people用有的所有属性和方法.
	student类的实例都能调用,student还要能丰富自己的类的属性和方法
	此时很简单,只需要巧妙设计原型链:
★★★★★★更改prototype,实现继承的核心语句★★★★★★
	stydent.prototype = new People();
	但是构造函数中的属性不能更改
	
	有一个引用包可以用来实现继承(爱前端邵  - 面向对象 -19课)
	*/
	
	
		</script>
	</body>
</html>
